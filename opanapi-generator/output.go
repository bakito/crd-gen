package main

import (
	_ "embed"
	"fmt"
	"maps"
	"slices"
	"sort"
	"strings"
	"text/template"
)

const myName = "opanapi-generator"

var (
	//go:embed group_version_into.go.tpl
	gviTpl string
	//go:embed types.go.tpl
	typeTpl string
)

// Generate Go code from struct definitions.
func generateTypesCode(structMap map[string]*StructDef, version, crdKind, plural, crdGroup, crdList string) string {

	// Sort and generate structs
	sortedStructNames := slices.Sorted(maps.Keys(structMap))

	var root *StructDef
	var structs []*StructDef

	for _, structName := range sortedStructNames {
		structDef := structMap[structName]

		structDef.Description = prepareDescription(structDef.Description, false)

		sort.Slice(structDef.Fields, func(i, j int) bool {
			return structDef.Fields[i].Name < structDef.Fields[j].Name
		})

		for i, f := range structDef.Fields {
			structDef.Fields[i].Description = prepareDescription(f.Description, true)
		}

		if structName == crdKind {
			// keep only spec and status
			var rootFields []FieldDef
			for _, field := range structDef.Fields {
				if field.JSONTag == "spec" || field.JSONTag == "status" {
					rootFields = append(rootFields, field)
				}
			}
			root = structDef
			root.Fields = rootFields
		} else {
			structs = append(structs, structDef)
		}
	}

	var sb strings.Builder
	t := template.Must(template.New("types.go.tpl").Parse(typeTpl))
	if err := t.Execute(&sb, map[string]any{
		"AppName": myName,
		"Version": version,
		"Group":   crdGroup,
		"Kind":    crdKind,
		"List":    crdList,
		"Plural":  toCamelCase(plural),
		"Root":    root,
		"Structs": structs,
	}); err != nil {
		println(err)
	}
	return sb.String()
}
func OLDgenerateTypesCode(structMap map[string]*StructDef, version, crdKind, plural, crdGroup, crdList string) string {
	var sb strings.Builder

	writef(&sb, "// Code generated by %s. DO NOT EDIT.\n\n", myName)
	writef(&sb, "package %s\n\n", version)

	// Add imports
	write(&sb, "import metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n")

	// Add comment header
	writef(&sb, "// Generated from %s.%s/%s CRD\n\n", crdKind, crdGroup, version)

	// Sort and generate structs
	sortedStructNames := slices.Sorted(maps.Keys(structMap))

	// write root struct
	writeStruct(structMap[crdKind], &sb, plural, crdList)

	for _, structName := range sortedStructNames {
		if crdKind != structName {
			structDef := structMap[structName]

			writeStruct(structDef, &sb, "", "")
		}
	}

	return sb.String()
}

func writeStruct(structDef *StructDef, sb *strings.Builder, plural, crdList string) {
	if structDef.Root {
		write(sb, "// +kubebuilder:object:root=true\n\n")
		write(sb,
			fmt.Sprintf("// %s is a list of %s.\n", crdList, toCamelCase(plural)),
		)
		writef(sb, "type %s struct {\n", crdList)
		write(sb, "\tmetav1.TypeMeta   `json:\",inline\"`\n")
		write(sb, "\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n")
		writef(sb, "\tItems []%s `json:\"items\"`\n", structDef.Name)
		write(sb, "}\n\n")

		write(sb, "// +kubebuilder:object:root=true\n\n")
	}

	// Add struct comment
	if structDef.Description != "" {
		d := prepareDescription(structDef.Description, false)
		writef(sb, "// %s\n", d)
	}

	// Start struct definition
	writef(sb, "type %s struct {\n", structDef.Name)

	// Add fields
	if structDef.Root {
		write(sb, "\tmetav1.TypeMeta   `json:\",inline\"`\n")
		write(sb, "\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n")
	}
	sort.Slice(structDef.Fields, func(i, j int) bool {
		return structDef.Fields[i].Name < structDef.Fields[j].Name
	})
	for _, field := range structDef.Fields {
		if !structDef.Root || field.Name == "Spec" || field.Name == "Status" {
			if field.Description != "" {
				d := prepareDescription(field.Description, true)
				writef(sb, "\t// %s\n", d)
			}
			writef(sb, "\t%s %s `json:\"%s,omitempty\"`\n", field.Name, field.Type, field.JSONTag)
		}
	}

	// Close struct definition
	write(sb, "}\n\n")

	// Enums
	for _, field := range structDef.Fields {
		if len(field.Enums) == 0 {
			continue
		}
		// Start enum definition
		writef(sb, "// %s represents an enumeration for %s\n", field.EnumName, field.Name)
		writef(sb, "type %s %s\n\n", field.EnumName, field.EnumType)
		write(sb, "var (\n")
		for _, e := range field.Enums {
			writef(sb, "\t// %s %s enum value %s\n", e.Name, field.Name, e.Value)
			writef(sb, "\t%s %s = %s\n", e.Name, field.EnumName, e.Value)
		}
		write(sb, ")\n\n")
	}
}

func generateGroupVersionInfoCode(group, version string, names []CRDNames) (string, error) {
	var sb strings.Builder
	t := template.Must(template.New("group_version_into.go.tpl").Parse(gviTpl))
	if err := t.Execute(&sb, map[string]any{
		"AppName":  myName,
		"Version":  version,
		"Group":    group,
		"CRDNames": names,
	}); err != nil {
		return "", err
	}

	return sb.String(), nil
}

func write(sb *strings.Builder, s string) {
	_, _ = sb.WriteString(s)
}

func writef(sb *strings.Builder, s string, args ...any) {
	write(sb, fmt.Sprintf(s, args...))
}
